
import {of as observableOf, throwError as observableThrowError,  Observable, Subject } from 'rxjs';

import {catchError, mergeMap, map} from 'rxjs/operators';
import { Injectable } from "@angular/core";
import { HttpClient } from "@angular/common/http";
import { EntityQuery, EntityState, MergeStrategy } from "../../libraries/breeze-client";

import { AppSettings } from "../../app-settings/app-settings";
import { Role } from "./entities/role";
import { User } from "./entities/user";
import { UserRole } from "./entities/user-role";
import { AppHttpClient } from "./app-http-client/app-http-client.module";
import { AppEntityManager } from "./app-entity-manager.service";
import { Logger } from "../logger/logger.module";
import { getUniqueUserName } from "../shared/utils";

@Injectable()
export class AuthService {

    // Public
    currentUser: User = null;
    currentUserChanged = new Subject<User>();

    get isBusy(): boolean {
        return this.appEntityManager.isBusy || this.appHttpClient.isBusy;
    }

    get loginReturnUrl(): string {
        return localStorage.getItem("loginReturnUrl");
    };
    set loginReturnUrl(value: string) {
        localStorage.setItem("loginReturnUrl", value);
    }

    // User cannot choose one of these folder/file names as its own username
    restrictUserNames = [
        "app",
        "assets",
        "_app_offline.htm",
        "app_offline.htm",
        "favicon.ico",
        "index.html",
        "robots.txt",
        "web.config"
    ];

    // Private
    private appHttpClient: AppHttpClient = null;
    private currentUserUrl = "";
    private registerUrl = "";
    private tokenUrl = "";

    constructor(private appEntityManager: AppEntityManager,
        private httpClient: HttpClient,
        private logger: Logger) {

        this.appHttpClient = httpClient as AppHttpClient;

        // Service urls
        this.currentUserUrl = AppSettings.serviceApiUrl + "/Account/CurrentUser";
        this.registerUrl = AppSettings.serviceApiUrl + "/Account/Register";
        this.tokenUrl = AppSettings.serviceApiUrl + "/Token";
    }

    ensureAuthenticatedUser() {
        if (this.currentUser.isAuthenticated()) {

            return observableOf(null);

        } else {

            const registerBindingModel = {
                UserName: this.currentUser.UserName,
                Email: this.currentUser.Email,
                AutoGenerated: true
            };

            return this.registerInternal(registerBindingModel).pipe(
                mergeMap(() => {
                    return this.getToken("", "", true, this.currentUser.SingleUseToken).pipe(map(() => {
                        this.logger.log("Guest account has created");
                    }));
                }));
        }
    }

    getUser(username: string): Observable<User> {

        const query = EntityQuery
            .from("Users")
            .expand("ProjectSet")
            .where("UserName", "eq", username);

        return this.appEntityManager.executeQueryObservable<User>(query).pipe(
            map((response) => {

                // If there is no result
                if (response.results.length === 0) {
                    return null;
                }

                return response.results[0];
            }));
    }

    init(): Observable<void> {

        // Get metadata from the server
        return this.appEntityManager.getMetadata().pipe(
            mergeMap(() => {

                // Set current user
                return this.setCurrentUser();
            }),
            catchError((error) => {

                // In case of "Server offline", set a new user to prevent further user related errors and continue
                if (typeof error.status !== "undefined"
                    && error.status === 0 &&
                    !this.currentUser) {

                    // User
                    this.currentUser = new User();

                    // User role
                    const userRole = new UserRole();
                    userRole.User = this.currentUser;
                    userRole.Role = new Role();
                    userRole.Role.Name = "Guest";
                    this.currentUser.Roles = [userRole];

                    return observableOf(null);
                } else {
                    throw error;
                }
            }),);
    }

    login(username: string, password: string, rememberMe: boolean, singleUseToken?: string): Observable<void> {

        return this.getToken(username, password, rememberMe, singleUseToken).pipe(
            mergeMap((): Observable<void> => {

                this.resetCurrentUser();

                return this.setCurrentUser();
            }));
    }

    logout(): Observable<void> {

        this.resetCurrentUser();

        localStorage.removeItem("token");

        return this.setCurrentUser();
    }

    register(registerBindingModel: any, rememberMe: boolean): Observable<void> {

        // Validate: Don't allow to set a username that is in "restrict usernames" list
        const username = registerBindingModel.UserName.toLowerCase();
        const restrictUsername = this.restrictUserNames.indexOf(username) > -1;

        if (restrictUsername) {
            return observableThrowError("Username is already taken.");
        }

        return this.registerInternal(registerBindingModel).pipe(
            mergeMap(() => {
                return this.getToken(registerBindingModel.UserName, registerBindingModel.Password, rememberMe);
            }));
    }

    saveChanges(): Observable<void> {

        return this.ensureAuthenticatedUser().pipe(
            mergeMap(() => {
                return this.appEntityManager.saveChangesObservable();
            }));
    }

    updateCurrentUser(updatedUser: User) {

        // Remove old user role
        const oldUserRole = this.currentUser.Roles[0];

        // From its role
        const oldRole = oldUserRole.Role;
        oldRole.Users.splice(oldRole.Users.indexOf(oldUserRole), 1);

        // From current user
        this.currentUser.Roles.splice(this.currentUser.Roles.indexOf(oldUserRole), 1);

        // And set it detached
        oldUserRole.entityAspect.setDetached();

        // User id fix-up
        this.currentUser.Id = updatedUser.Id;

        // Update breeze entities
        this.appEntityManager.createEntity("User", updatedUser, EntityState.Unchanged, MergeStrategy.OverwriteChanges);
        this.appEntityManager.createEntity("UserRole", updatedUser.Roles[0], EntityState.Unchanged, MergeStrategy.OverwriteChanges);
    }

    // Private methods
    private createGuestAccount(): User {

        // Username: Look for it in localStorage first
        let userName = localStorage.getItem("guestUserName");

        // If there is no guest username, generate a unique username and add it to localStorage
        // If the user refreshes the page, it can keep using the same username
        if (!userName) {
            userName = getUniqueUserName();
            localStorage.setItem("guestUserName", userName);
        }

        // Email
        const email = `${userName}@forcrowd.org`;

        const user = this.appEntityManager.createEntity("User", {
            Email: email,
            UserName: userName
        }) as User;
        user.entityAspect.acceptChanges();

        // Get guest role
        const guestRole = this.appEntityManager.getEntities("Role").find((value: Role) => {
            return value.Name === "Guest";
        });

        // User role
        const userRole = this.appEntityManager.createEntity("UserRole", { User: user, Role: guestRole });
        userRole.entityAspect.acceptChanges();

        return user;
    }

    // Ensures Role entities are retrieved
    private ensureRolesEntities(): Observable<void> {

        if (this.appEntityManager.getEntities("Role").length > 0) {

            return observableOf(null);

        } else {

            const query = EntityQuery.from("Roles");

            return this.appEntityManager.executeQueryObservable(query).pipe(map(() => { }));
        }
    }

    private getToken(username: string, password: string, rememberMe: boolean, singleUseToken?: string) {

        const tokenData = `grant_type=password&username=${username}&password=${password}&rememberMe=${rememberMe}&singleUseToken=${singleUseToken}`;

        return this.appHttpClient.post<Object>(this.tokenUrl, tokenData).pipe(
            map((token) => {
                localStorage.setItem("token", JSON.stringify(token)); // Store the token in localStorage
            }));
    }

    private registerInternal(registerBindingModel: any): Observable<void> {

        registerBindingModel.ClientAppUrl = window.location.origin;

        return this.appHttpClient.post<User>(this.registerUrl, registerBindingModel).pipe(
            map((updatedUser: User) => {
                this.updateCurrentUser(updatedUser);

                localStorage.removeItem("guestUserName");
            }));
    }

    private resetCurrentUser(): void {

        this.appEntityManager.clear();

        this.currentUser = null;

        localStorage.removeItem("guestUserName");

    }

    private setCurrentUser(): Observable<void> {

        return this.ensureRolesEntities().pipe(mergeMap(() => {

            const tokenItem = localStorage.getItem("token");

            if (tokenItem === null) {

                this.currentUser = this.createGuestAccount();

                this.currentUserChanged.next(this.currentUser);

                return observableOf(null);

            } else {

                return this.appHttpClient.get<User>(this.currentUserUrl).pipe(
                    map(currentUser => {

                        if (currentUser === null) {

                            localStorage.removeItem("token"); // Invalid or expired token

                            this.currentUser = this.createGuestAccount();

                        } else {

                            // Attach user and its role to entity manager
                            this.currentUser = this.appEntityManager.createEntity("User", currentUser, EntityState.Unchanged) as User;
                            this.appEntityManager.createEntity("UserRole", currentUser.Roles[0], EntityState.Unchanged);

                        }

                        this.currentUserChanged.next(this.currentUser);
                    }));
            }
        }));
    }
}
